name: Verify Subdomain PR

on:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  verify:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Gather changed files
        id: files
        run: |
          git fetch origin ${{ github.base_ref }}
          git diff --name-status origin/${{ github.base_ref }} > changes.txt
          cat changes.txt

      - name: Validate PR
        run: |
          set -e

          USER="${{ github.actor }}"
          RESERVED="reserved.txt"
          BLOCKED="blocked.txt"
          PROTECTED_FILES=("LICENSE.md" "README.md" "RULES.md" "CONTRIBUTING.md")

          # Load reserved and blocked subdomains
          if [ -f "$RESERVED" ]; then
            mapfile -t RESERVED_NAMES < "$RESERVED"
          else
            RESERVED_NAMES=()
          fi

          if [ -f "$BLOCKED" ]; then
            mapfile -t BLOCKED_NAMES < "$BLOCKED"
          else
            BLOCKED_NAMES=()
          fi

          error_exit() {
            echo "❌ $1"
            exit 1
          }

          # Gather all existing subdomains (excluding current user)
          EXISTING_SUBS=()
          for f in records/*/*.json; do
            [[ "$f" =~ ^records/$USER/ ]] && continue
            SUB=$(jq -r '.subDomain' "$f")
            EXISTING_SUBS+=("$SUB")
          done

          while read STATUS FILE; do
            echo "Checking $STATUS $FILE"

            # Block workflow edits
            if [[ "$FILE" =~ ^.github/ ]]; then
              error_exit "Editing workflow files is not allowed"
            fi

            # Block edits to protected files
            for P in "${PROTECTED_FILES[@]}"; do
              if [[ "$FILE" == "$P" ]]; then
                error_exit "Editing $FILE is not allowed"
              fi
            done

            # Must be in user's own folder
            if [[ "$FILE" =~ ^records/ ]]; then
              if [[ ! "$FILE" =~ ^records/$USER/[^/]+\.json$ ]]; then
                error_exit "Files inside records/ must be in your own folder: records/$USER/"
              fi

              # Allow add, modify, delete
              if [[ ! "$STATUS" =~ ^(A|M|D)$ ]]; then
                error_exit "Only add, modify, or delete allowed in your folder"
              fi

              # Validate JSON only for add/modify
              if [[ "$STATUS" != "D" ]]; then
                # Check valid JSON
                jq . "$FILE" > /dev/null 2>&1 || error_exit "Invalid JSON in $FILE"

                # Check required fields
                for key in "githubUname" "publicEmail" "desc" "domain" "subDomain" "records"; do
                  VALUE=$(jq -r --arg k "$key" '.[$k] // empty' "$FILE")
                  if [[ -z "$VALUE" ]]; then
                    error_exit "Missing required field '$key' in $FILE"
                  fi
                done

                # Check subdomain uniqueness
                PR_SUB=$(jq -r '.subDomain' "$FILE")
                for s in "${EXISTING_SUBS[@]}"; do
                  if [[ "$PR_SUB" == "$s" ]]; then
                    error_exit "Subdomain '$PR_SUB' already exists for another user"
                  fi
                done

                # Check records array
                COUNT=$(jq '.records | length' "$FILE")
                if [[ "$COUNT" -eq 0 ]]; then
                  error_exit "'records' array is empty in $FILE"
                fi

                # Validate each record
                for i in $(seq 0 $(($COUNT - 1))); do
                  NAME=$(jq -r ".records[$i].name // empty" "$FILE")
                  TYPE=$(jq -r ".records[$i].type // empty" "$FILE")
                  VALUE=$(jq -r ".records[$i].value // empty" "$FILE")
                  PROXIED=$(jq -r ".records[$i].proxied // empty" "$FILE")

                  if [[ -z "$NAME" || -z "$TYPE" || -z "$VALUE" ]]; then
                    error_exit "Record #$i in $FILE is missing 'name', 'type', or 'value'"
                  fi

                  # Allowed types
                  if [[ ! "$TYPE" =~ ^(A|AAAA|CNAME|TXT)$ ]]; then
                    error_exit "Record #$i in $FILE has invalid type '$TYPE'"
                  fi

                  # Proxied can be true/false if exists
                  if [[ -n "$PROXIED" ]]; then
                    if [[ ! "$PROXIED" =~ ^(true|false)$ ]]; then
                      error_exit "Record #$i in $FILE has invalid 'proxied' value '$PROXIED'"
                    fi
                  fi
                done

                # Extract first label
                FIRST_LABEL="${PR_SUB%%.*}"

                # Check blocked.txt - blocked everywhere
                for b in "${BLOCKED_NAMES[@]}"; do
                  if [[ "$b" == *"*" ]]; then
                    PREFIX="${b%\*}"
                    if [[ "$PR_SUB" == "$PREFIX"* ]] || [[ "$FIRST_LABEL" == "$PREFIX"* ]]; then
                      error_exit "Subdomain '$PR_SUB' is completely blocked"
                    fi
                  else
                    if [[ "$PR_SUB" == "$b" ]] || [[ "$FIRST_LABEL" == "$b" ]]; then
                      error_exit "Subdomain '$PR_SUB' is completely blocked"
                    fi
                  fi
                done

                # Check reserved.txt - block root level only
                for r in "${RESERVED_NAMES[@]}"; do
                  if [[ "$r" == *"*" ]]; then
                    PREFIX="${r%\*}"
                    if [[ "$FIRST_LABEL" == "$PREFIX"* ]]; then
                      error_exit "Subdomain '$PR_SUB' is reserved at root level"
                    fi
                  else
                    if [[ "$FIRST_LABEL" == "$r" ]]; then
                      error_exit "Subdomain '$PR_SUB' is reserved at root level"
                    fi
                  fi
                done

              fi
            else
              # Any files outside records/ cannot be modified/added/deleted
              error_exit "You cannot CRUD files outside your own records folder"
            fi

          done < changes.txt

          echo "✅ All checks passed"
